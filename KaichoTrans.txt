KaichoTrans概要：
	KaichoTransは、吉里吉里にトランジションを追加するプラグインである。
	大体SSE2を使っているので、Pentium4以上じゃないと動かないことに注意。
使い方：
	scenario/first.ks の先頭あたりで、プラグイン本体を以下のように読込む。
		Plugins.link("KaichoTrans.dll");
	以降、追加したトランジションが使用可能になる。

▼ ブラートランジション =====================================================
	BoxBlurをつかったブラートランジション。画面をこう…にじませる、という
	ヤツ。extNagano.dllのfadeblurと同じだが、こっちの方がかなり高速。
	白あるいは黒など、単色へ/からのブラートランジションが綺麗だと思う。
　引数：
	[trans method=blur time= blur1= blur1x= blur1y= blur2= blur2x= blur2y=]
	method=blur
		ブラートランジションを指定する。
	time=	トランジションの所要時間を指定する。(ms)。
	blur1=	トランジション元画像をどこまでブラーでにじませるかの半径を
		指定する。def=32。次のblur1xとblur1yが指定されなかったら
		この値となる。0にするとにじませない。
	blur1x=	トランジション元画像をどこまでX方向にブラーでにじませるかの
		半径を指定する。
	blur1y=	トランジション元画像をどこまでY方向にブラーでにじませるかの
		半径を指定する。
	blur2=	トランジション先画像をどこまでブラーでにじませるかの半径を
		指定する。0にするとにじませない。
		def=32。次のblur2xとblur2yが指定されなかったらこの値となる。
	blur2x=	トランジション先画像をどこまでX方向にブラーでにじませるかの
		半径を指定する。
	blur2y=	トランジション先画像をどこまでY方向にブラーでにじませるかの
		半径を指定する。
	accel=	ブラーを変化させる割合を指定する。def=1.0。
		>1.0 で最初ゆっくりあと早く、<-1.0で最初はやくあとゆっくり。
	dynamic=false(def)|true
		動的な画面をブラーする時に指定する。通常はトランジションの
		最初に初期化を全部終わらせるので、静的な画面しかブラートラン
		ジションできないが高速。この引数付けると動的な画面をブラー
		トランジションできるが、倍以上遅くなる。使い所に注意。
　備考：
	・最初にボックスブラーのインテグラルイメージをドカンと作るので、トラン
	　ジション開始→終了までの間、結構メモリを食う。例えばゲーム画面
	　1024x768でblur1=blur2=32dotの場合、使用メモリ量は
		(1024+32x2+1)x(768+32x2+1+1)*4(color)*4(byte)*2(枚)
		= 27982944 ≒ 28MB
	　となる。まぁ…Pen4以上のマシンで、テンポラリに30MBのメモリを
	　確保できないなんてこたないだろうから、男らしく気にしないことに
	　している。
	　とはいえ、あんまりブラーサイズ(blur1やblur2)が大きい(1000以上とか)
	　と、メモリとCPUをたんまり食うのでオススメしない。
	・最初 TJSAlignedAlloc() 使ってメモリ確保してたら、メモリはたくさん
	　あるはずなのにbad allocが出まくったので、今は __aligned_malloc()
	　を使用している。これだとなぜかbad allocが出ない。理由は知らん。
	　教えてくれた方には飴ちゃんプレゼント。
	・省メモリ版(大体1/10くらい)を作ったが、遅いので採用を見送った。
	　Core3i(2120T)でblurを1000回連続実行して1/1000した時の実測値(ms)は
	　以下の通り。トータルが最も高速なのは今回採用版。
		今回採用版　　 　　省メモリ版(+SSE2)　　Layer.doBoxBlur()
		初回　　　3.85ms　　　毎回 2.26ms　　　　　毎回 3.62ms
		次回以降　1.02ms
	・それにしても、吉里吉里デフォルトのLayer.doBoxBlur()はスバらしい！
	　普通にCで組んだら、その速度に全然かなわなかったよ。人力アセンブラ
	　最適化とSSE2使って上の結果、やっと辛勝くらい。MMXって思いの他
	　速いのね。
	・dynamic引数を追加。これだと、「今回採用版」の「初回」をずっと
	　繰り返すことになるので遅い。しかし、分割画面のトランジションに
	　対応するには、そういう方法しか思いつかなかった。そうじゃなければ
	　上の「省メモリ版」が使えるのに。

▼ ディムトランジション =====================================================
	にじみ出るようなディム(dim)トランジション。黒いところ、白いところ
	からこう…じわっとにじみ出るように次の画面が出てくるというそんな。
	内部的には、ruleで指定された画像を白黒化→ブラーして、それを
	universalトランジションしている。

　引数：
	[trans method=dim rule= time= blur= xblur= yblur= neg= vague= accel=]
	method=dim
		ディムトランジションを指定する。
	rule=	トランジションのルール画像を指定する。何でもいいが、トランジ
		ション元の画像を指定するとこっちが狙ってた効果が出る。
	time=	トランジションの所要時間を指定する。(ms)。
	blur=	ルール画像をどこまでブラーでにじませるかの半径を指定する。
		def=16。次のxblurとyblurが指定されなかったらこの値となる。
		0にするとにじませない。
	xblur=	ルール画像をどこまでX方向にブラーでにじませるかの半径を
		指定する。
	yblur=	ルール画像をどこまでY方向にブラーでにじませるかの半径を
		指定する。
	neg=	ルール画像を白黒反転させるかどうか。def=false。
	vague=	あいまい部分をどれだけ使うかを指定する。def=64。
		universalトランジションのvagueと同じ。
	accel=	ディムを変化させる割合を指定する。def=1.0。
		>1.0 で最初ゆっくりあと早く、<-1.0で最初はやくあとゆっくり。
　備考：
	・内部的にボックスブラーしているが、こっちは省メモリ版なので、
	　1024x768画像を32x32ブラーしても300KB食わない。
	・当然これもSSE2使っているが、まぁ…気休め。

今後の展望：
	・extNagano.dllみたく、どんどんトランジションが追加できるといいなぁ。
	・汎用的で見栄えがよくてみんな喜ぶナイスなトランジションを
	　思いついたら、こっそり教えて下さい。時間があったら作ってみたいので。

独り言：
	・extNagano.dllはスバらしいのに開発止まっちゃってるのとソースコードが
	　オープンでないからアレ以上発展しないのがモノスゴもったいない。
	　ソースコードくんないかしら。遅そうならSSE2で高速化しちゃう所存ナリ。

変更履歴：
	2015/06/20	0.2.5.1 VC++2010に移行。何故かは全くわからないけれど、
				VC++2008で作ったバイナリは _align_malloc()に
				失敗することがあったため。コードは一行も変えて
				ない。おかげでWin2kでは動かなくなった…。
	2011/12/09	0.2.5.0	blurにdynamic引数を追加
	2011/12/09	0.2.1.0	blurがメモリ不足になってたのを修正(したつもり)
				blurにaccelを追加
				dimを追加
	2011/12/03	0.1	blurのみ実装してリリース
